<!DOCTYPE html>
<html lang="es">
<head>
Â  <meta charset="UTF-8" />
Â  <meta name="viewport" content="width=device-width, initial-scale=1" />
Â  <title>Control por Gestos Optimizado</title>
Â  <link rel="stylesheet" href="estilos.css" />
</head>
<body>
Â  <img src="infocal.jpg" width="200px"/> 
Â  <div id="container">
Â  Â  <h2>Control por gestos con la mano</h2>
Â  Â  <button id="toggleCam">Activar cÃ¡mara</button>
Â  Â  <p id="feedback">CÃ¡mara apagada</p>
Â  Â  <video id="video" autoplay playsinline></video>

Â  Â  <div class="content">
Â  Â  Â  <h3>Instrucciones:</h3>
Â  Â  Â  <ul>
        Â  Â  Â  Â  <li>Presiona "Activar cÃ¡mara" para comenzar.</li>
Â  Â  Â  Â  <li>Mueve la mano <strong>ARRIBA</strong> para subir la pÃ¡gina.</li>
Â  Â  Â  Â  <li>Mueve la mano <strong>ABAJO</strong> para bajar la pÃ¡gina.</li>
Â  Â  Â  Â  <li>Mueve la mano al <strong>CENTRO-IZQUIERDA</strong> para ir AtrÃ¡s.</li> Â  Â  Â  Â  <li>Mueve la mano al <strong>CENTRO-DERECHA</strong> para ir Adelante.</li> Â  Â  Â  Â  <li><strong>CIERRA LA MANO</strong> para tomar una captura.</li>
        <li><strong>PELLIZCA (dedos Ã­ndice y pulgar)</strong> para recargar la pÃ¡gina.</li> Â  Â  Â  Â  <p>
Â  Â  Â  Â  Este proyecto bÃ¡sico de control por gestos con la mano utiliza inteligencia artificial y visiÃ³n computacional para permitir una interacciÃ³n natural y sin contacto con dispositivos digitales. Basado en el modelo Handpose de TensorFlow.js, el sistema detecta movimientos y posiciones de la mano en tiempo real para controlar funciones como el desplazamiento (scroll) y la captura de pantalla. Esta tecnologÃ­a puede aplicarse en diversas Ã¡reas de la vida real, como en la accesibilidad para personas con movilidad limitada, interfaces de control en entornos donde no se puede tocar la pantalla (por ejemplo, quirÃ³fanos o industrias limpias), o en dispositivos inteligentes para una experiencia de usuario mÃ¡s intuitiva y fluida. AdemÃ¡s, al ser una soluciÃ³n basada en navegador y sin necesidad de hardware especial, permite una implementaciÃ³n rÃ¡pida y flexible en mÃºltiples plataformas.
Â  Â  Â  Â  </p>
Â  Â  Â  </ul>
Â  Â  Â  
Â  Â  </div>
Â  </div>
Â  Â <footer id="pie-pagina">
Â  Â  &copy; Autor: JosÃ© Cristhian Rojas Escalante - Proyecto de navegaciÃ³n por gestos con cÃ¡mara. 2025. Â 
Â  </footer>

Â  Â  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
Â  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
Â  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
Â  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose"></script>

Â  <script>
Â  Â  const video = document.getElementById("video");
Â  Â  const toggleBtn = document.getElementById("toggleCam");
Â  Â  const feedback = document.getElementById("feedback");

    // --- NUEVAS CONSTANTES PARA MEJOR LEGIBILIDAD ---
    const SCROLL_ZONE_TOP = 0.3;      // 30% superior para scroll arriba
    const SCROLL_ZONE_BOTTOM = 0.7;   // 70% inferior para scroll abajo
    const SWIPE_ZONE_LEFT = 0.3;      // 30% izquierdo para swipe
    const SWIPE_ZONE_RIGHT = 0.7;     // 70% derecho para swipe
    const DETECTION_INTERVAL_MS = 150; // Intervalo de detecciÃ³n
    const ACTION_COOLDOWN_MS = 1500;  // Enfriamiento para swipe y recarga
    const PINCH_THRESHOLD = 30;       // Distancia (en pÃ­xeles) para detectar pellizco

Â  Â  let model, stream;
Â  Â  let cameraActive = false;
Â  Â  let lastActionTime = 0;
Â  Â  let lastGesture = "";
Â  Â  let scrollAnimationFrame = null;

Â  Â  async function initCamera() {
Â  Â  Â  stream = await navigator.mediaDevices.getUserMedia({
Â  Â  Â  Â  video: { 
            width: { ideal: 640 }, // <-- MODIFICADO (480p)
            height: { ideal: 480 }, // <-- MODIFICADO (480p)
            facingMode: "user" 
        },
Â  Â  Â  Â  audio: false
Â  Â  Â  });
Â  Â  Â  video.srcObject = stream;
Â  Â  Â  video.playsInline = true;
Â  Â  Â  await video.play();
Â  Â  }

Â  Â  async function loadModel() {
Â  Â  Â  if (!model) model = await handpose.load();
Â  Â  }

    // --- FUNCIONES DE DETECCIÃ“N DE GESTOS ---

Â  Â  function isHandClosed(landmarks) {
Â  Â  Â  const tips = [8, 12, 16, 20]; // Puntas de los dedos (Ã­ndice, medio, anular, meÃ±ique)
Â  Â  Â  // Comprueba si las puntas de los dedos estÃ¡n mÃ¡s bajas (mayor valor Y) que sus nudillos
Â  Â  Â  return tips.every(tip => landmarks[tip][1] > landmarks[tip - 2][1]);
Â  Â  }

    function getDistance(p1, p2) { // <-- NUEVA FUNCIÃ“N (calcula distancia 2D)
      return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
    }

    function isPinching(landmarks) { // <-- NUEVA FUNCIÃ“N
      const thumbTip = landmarks[4];
      const indexTip = landmarks[8];
      const distance = getDistance(thumbTip, indexTip);
      return distance < PINCH_THRESHOLD;
    }

Â  Â  function getHandCenterY(landmarks) {
Â  Â  Â  return landmarks.reduce((sum, point) => sum + point[1], 0) / landmarks.length;
Â  Â  }

    function getHandCenterX(landmarks) { // <-- NUEVA FUNCIÃ“N
Â  Â  Â  return landmarks.reduce((sum, point) => sum + point[0], 0) / landmarks.length;
Â  Â  }

    // --- FUNCIONES DE ACCIÃ“N ---

Â  Â  function flashScreen() {
Â  Â  Â  const flash = document.createElement('div');
Â  Â  Â  Object.assign(flash.style, {
Â  Â  Â  Â  position: 'fixed', top: 0, left: 0, width: '100vw', height: '100vh',
Â  Â  Â  Â  backgroundColor: 'white', opacity: '0.8', zIndex: '9999', pointerEvents: 'none'
Â  Â  Â  });
Â  Â  Â  document.body.appendChild(flash);
Â  Â  Â  setTimeout(() => flash.style.opacity = '0', 100);
Â  Â  Â  setTimeout(() => document.body.removeChild(flash), 600);
Â  Â  }

Â  Â  function takeScreenshot() {
Â  Â  Â  const canvas = document.createElement("canvas");
Â  Â  Â  canvas.width = video.videoWidth;
Â  Â  Â  canvas.height = video.videoHeight;
Â  Â  Â  const ctx = canvas.getContext("2d");
Â  Â  Â  ctx.drawImage(video, 0, 0);
Â  Â  Â  const link = document.createElement("a");
Â  Â  Â  link.download = `captura_${new Date().toISOString().replace(/[:.]/g, "-")}.png`;
Â  Â  Â  link.href = canvas.toDataURL("image/png");
Â  Â  Â  link.click();
Â  Â  Â  flashScreen();
Â  Â  Â  feedback.textContent = "ğŸ“¸ Â¡Captura tomada!";
Â  Â  Â  setTimeout(() => feedback.textContent = "", 2000);
Â  Â  }

Â  Â  function startScroll(direction) {
Â  Â  Â  stopScroll(); 
Â  Â  Â  function scrollStep() {
Â  Â  Â  Â  window.scrollBy({ top: direction === "up" ? -10 : 10, behavior: "auto" });
Â  Â  Â  Â  scrollAnimationFrame = requestAnimationFrame(scrollStep);
Â  Â  Â  }
Â  Â  Â  scrollAnimationFrame = requestAnimationFrame(scrollStep);
Â  Â  }

Â  Â  function stopScroll() {
Â  Â  Â  if (scrollAnimationFrame) {
Â  Â  Â  Â  cancelAnimationFrame(scrollAnimationFrame);
Â  Â  Â  Â  scrollAnimationFrame = null;
Â  Â  Â  }
Â  Â  }

    // --- BUCLE PRINCIPAL DE DETECCIÃ“N (MODIFICADO) ---

Â  Â  async function detectHands() {
Â  Â  Â  if (!cameraActive || !model) return;

Â  Â  Â  const predictions = await model.estimateHands(video, true);
Â  Â  Â  const now = Date.now();
      const hasCooldown = (now - lastActionTime > ACTION_COOLDOWN_MS);

Â  Â  Â  if (predictions.length > 0) {
Â  Â  Â  Â  const landmarks = predictions[0].landmarks;
Â  Â  Â  Â  const handCenterY = getHandCenterY(landmarks);
Â  Â  Â  Â  const videoHeight = video.videoHeight;

        // --- LÃ“GICA DE GESTOS REESTRUCTURADA ---
        
        // 1. Gesto de PuÃ±o (Captura) - MÃ¡xima prioridad
Â  Â  Â  Â  if (isHandClosed(landmarks)) {
Â  Â  Â  Â  Â  stopScroll();
Â  Â  Â  Â  Â  if (lastGesture !== "cerrada" && hasCooldown) {
Â  Â  Â  Â  Â  Â  takeScreenshot();
Â  Â  Â  Â  Â  Â  lastActionTime = now;
Â  Â  Â  Â  Â  Â  lastGesture = "cerrada";
Â  Â  Â  Â  Â  }
        // 2. Gesto de Pellizco (Recargar) - Siguiente prioridad
        } else if (isPinching(landmarks)) { // <-- NUEVO
          stopScroll();
          if (lastGesture !== "pinch" && hasCooldown) {
            feedback.textContent = "ğŸ‘Œ Pellizco: Recargando pÃ¡gina...";
            lastActionTime = now;
            lastGesture = "pinch";
            location.reload();
          }
        // 3. Gestos de Scroll y Swipe (Mano abierta)
Â  Â  Â  Â  } else {
          // 3a. Scroll Vertical (Arriba/Abajo)
Â  Â  Â  Â  Â  if (handCenterY < videoHeight * SCROLL_ZONE_TOP) {
            if (lastGesture !== "arriba") {
Â  Â  Â  Â  Â  Â    feedback.textContent = "ğŸ– Mano arriba: Scroll arriba";
Â  Â  Â  Â  Â  Â    startScroll("up");
Â  Â  Â  Â  Â  Â    lastGesture = "arriba";
            }
Â  Â  Â  Â  Â  } else if (handCenterY > videoHeight * SCROLL_ZONE_BOTTOM) {
            if (lastGesture !== "abajo") {
Â  Â  Â  Â  Â  Â    feedback.textContent = "ğŸ– Mano abajo: Scroll abajo";
Â  Â  Â  Â  Â  Â    startScroll("down");
Â  Â  Â  Â  Â  Â    lastGesture = "abajo";
            }
          // 3b. Zona Central (Swipe Horizontal o Parar)
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  stopScroll();
            const handCenterX = getHandCenterX(landmarks); // <-- NUEVO
            const videoWidth = video.videoWidth; // <-- NUEVO

            if (handCenterX < videoWidth * SWIPE_ZONE_LEFT) {
                if (lastGesture !== "izquierda" && hasCooldown) {
                  feedback.textContent = "ğŸ‘ˆ Mano Izquierda: AtrÃ¡s";
                  lastGesture = "izquierda";
                  lastActionTime = now;
                  history.back();
                }
            } else if (handCenterX > videoWidth * SWIPE_ZONE_RIGHT) {
                if (lastGesture !== "derecha" && hasCooldown) {
                  feedback.textContent = "ğŸ‘‰ Mano Derecha: Adelante";
                  lastGesture = "derecha";
                  lastActionTime = now;
                  history.forward();
                }
            } else {
              // EstÃ¡ en el centro-centro
              if (lastGesture !== "medio") {
                feedback.textContent = "âœ‹ Mano en el centro: sin acciÃ³n";
                lastGesture = "medio";
              }
            }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  } else {
        // No se detecta mano
Â  Â  Â  Â  if (lastGesture !== "") {
          feedback.textContent = "ğŸ” Esperando mano...";
Â  Â  Â  Â    lastGesture = "";
Â  Â  Â  Â    stopScroll();
        }
Â  Â  Â  }

Â  Â  Â  setTimeout(detectHands, DETECTION_INTERVAL_MS);
Â  Â  }

Â  Â  toggleBtn.onclick = async () => {
Â  Â  Â  if (!cameraActive) {
Â  Â  Â  Â  try { // <-- NUEVO (Manejo de errores)
Â  Â  Â  Â    toggleBtn.textContent = "Cargando...";
Â  Â  Â  Â    toggleBtn.disabled = true;
          feedback.textContent = "Iniciando cÃ¡mara y modelo...";
          
Â  Â  Â  Â    await initCamera();
Â  Â  Â  Â    await loadModel();

          toggleBtn.textContent = "Desactivar cÃ¡mara";
          feedback.textContent = "ğŸŸ¢ CÃ¡mara activada";
Â  Â  Â  Â    video.style.display = "block";
Â  Â  Â  Â    cameraActive = true;
          toggleBtn.disabled = false;
Â  Â  Â  Â    detectHands();
        } catch (error) { // <-- NUEVO (Manejo de errores)
          console.error("Error al iniciar la cÃ¡mara:", error);
          feedback.textContent = "âŒ Error: No se pudo acceder a la cÃ¡mara.";
          toggleBtn.textContent = "Activar cÃ¡mara";
          toggleBtn.disabled = false;
          cameraActive = false;
        }
Â  Â  Â  } else {
Â  Â  Â  Â  stream.getTracks().forEach(track => track.stop());
Â  Â  Â  Â  video.srcObject = null;
Â  Â  Â  Â  video.style.display = "none";
Â  Â  Â  Â  toggleBtn.textContent = "Activar cÃ¡mara";
Â  Â  Â  Â  feedback.textContent = "ğŸ”´ CÃ¡mara apagada";
Â  Â  Â  Â  cameraActive = false;
Â  Â  Â  Â  stopScroll();
Â  Â  Â  }
Â  Â  }; 
Â  </script>
</body>
</html>